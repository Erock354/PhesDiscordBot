import random
from datetime import datetime
import urllib.request
import os.path
import os

from code import discord_token
import discord
from discord.ext import commands
from waifu_service import get_url, get_post
from images_service import get_image, get_reaction
from data_handler import dir_init, log

# Permessi
intents = discord.Intents.all()
intents.message_content = True
COMMAND_PREFIX = '$'
# Setting del bot
client = commands.Bot(command_prefix=COMMAND_PREFIX, intents=intents, description='Fes gaming', help_command=None)


# Questo evento viene eseguito appena viene avviato il Bot
@client.event
async def on_ready():
    # Tipo di attività (in questo caso listening)
    activity_type = discord.ActivityType.playing

    # Nome dell'attività (posso metterci dentro quello che voglio)
    activity_name = f'{COMMAND_PREFIX}help if you need me :D'

    # Setting della presence (Attività)
    await client.change_presence(activity=discord.CustomActivity(type=activity_type, name=activity_name))

    # Inserimento dei Cog (gruppi di comandi, eventi...)
    await client.add_cog(CommandErrorHandler(client))
    await client.add_cog(Test(client))
    await client.add_cog(Anime(client))
    await client.add_cog(Image(client))

    # Appena viene avviato manda un messaggio nel terminale
    print('I am ready for the use')
    print(' ')


# Cog test
# I Cog possiamo vederli come degli insiemi di comandi
# Questo insieme contiene solo un comando hello che risponde con hello o un differente messaggio se eseguito due volte
# di fila dalla stessa persona
class Test(commands.Cog):

    # __inti__ è letteralmente il costruttore del Cog.
    def __init__(self, bot):
        self.bot = bot
        self._last_member = None
        self.catergory_details = {
            'image': 'This list of commands can manipulate YOUR images.',
            'anime': 'This list of commands provides anime content using waifu.pics free API'
        }
        self.commad_details = {
            'waifu': 'This command generate a waifu pic.',
            'neko': 'This command generate a waifu pic.',
            'shinobu': 'This command generate a pic of Shinobu from Bakemonogatari',
            'megumin': 'This command generate a pic of Megumin from Konosuba',
            'bully': 'This command generate an anime bully gif',
            'cuddle': 'This command generate an anime cuddle gif',

            'image': 'Using this command you can generate an image composed by 2 pictures, an arrow and text on the '
                     'top (optional).\n '
                     'The image will be sent in an embed.'
                     'The first pic is the background. '
                     'This pic will be resized to 512x512.\n'
                     'The second pic is placed down-left.'
                     'This pic will be resized to 128x128.\n'
                     'The arrow is placed down-left pointing to the center.\n\n'

                     'By default (without any argument) the first pic is an image of a Floppa generated by an IA and '
                     'the down-left pic is the avatar of the user who invoke the command.\n\n'

                     'With this command you can combine different argument: \n\n'

                     '_$image <mention>_ : This will change the down-left pic by using the avatar of the mentioned '
                     'user.\n\n'

                     '_$image <one image attached>_ : The command and the attached image must be in the same '
                     'message. This will be the background.\n\n'

                     '_$image <mention> <one image attached>_ : The background will be the attached image and the '
                     'down-left pic will be the mentioned user avatar.\n\n'

                     '_$image <two image attached>_ : The first image attached will be the background and the second '
                     'image attached will be the down-left pic.\n\n'

                     "You can't use this command with a _<mention>_ and _<two attached image>_ . "
                     "This will raise an error.\n\n"

                     'You can add text to the image by adding text after the command like this. "$image my text".\n'
                     'If you want to add text and mention an user your command will look like this. '
                     '"$image _<mention>_ my text". (You can also put the <mention> at the end or in the middle of '
                     'the message, the command will automatically take only the text and ignore the mentions)\n\n'

                     'After the embed has been sent your command will be deleted by the Bot. \n\n'

                     '**Recommendations**\n'
                     "Don't share private images. The attached image will be saved in a specific folder created for "
                     'this server.\n'
                     "Don't share private information via text using this command. The text you insert via command "
                     "will be saved in a specific file created for this server.\n"
                     "Hope this information help you.",

            'avatar': 'This command send an embed with the avatar of the user who invoke this command.\n'
                      'You can mention an user and get his avatar. Example "$avatar <mention>"',

            'reaction': 'This command generate a "live reaction" image.\n'
                        'The image will be sent in an embed.\n\n'
                        'This command by default take the avatar of the user that invoked the command and use it for '
                        'the live reaction, otherwise you can mention  an user (this will use the avatar of the '
                        "mentioned user) or attach an image (this will use the attached image), remember that you can "
                        "use only one of this two types of arguments.\n\n"
                        'Examples: _$reaction <mention>_, _$reaction <one attached image>_, the command and the '
                        'attached image must be in the same message.\n\n'
                        '**Recommendations**\n'
                        "Don't share private images. The attached image will be saved in a specific folder created for "
                        'this server.\n',

            'random': "This command it's the same as image but with random image and random text.\n"
                      "The random image will be taken from the specific directory of this server where are stored the "
                      "attached images.\n"
                      "The random text will be taken from the specific file of this server where are stored all the "
                      "text the users used for the image command.\n\n"
                      "**Reccomanation**\n"
                      "Before use this command, you must use the command _$image_ at least once times with attached "
                      "images and text."
        }

    # Comando hello. Per creare dei comandi all'interno dei Cog devi usare il decoratore @commands.command()
    # Esistono altri modi ma io uso questo perché è comodo.

    @commands.command()
    async def hello(self, ctx, *, member: discord.Member = None):
        member = member or ctx.author
        if self._last_member is None or self._last_member.id != member.id:
            await ctx.send(f'Hello {member.name}~')
        else:
            await ctx.send(f'Hello {member.name}... This feels familiar.')
        self._last_member = member

    @commands.command()
    async def help(self, ctx, arg1: str = None):
        if arg1:
            arg1 = arg1.lower()
        if arg1 is None:
            embed = discord.Embed(title='Help',
                                  description=f'Here you can find the list of commands divided into categories.\n'
                                              f'Use *{COMMAND_PREFIX}help <command_name>* for more details.',
                                  color=0xD8BFD8)
            embed.add_field(name="Anime commands (SFW)",
                            value='waifu\n'
                                  'neko\n'
                                  'shinobu\n'
                                  'megumin\n'
                                  'bully\n'
                                  'cuddle',
                            inline=True)

            embed.add_field(name="Image commands",
                            value='image\n'
                                  'reaction\n'
                                  'avatar\n'
                                  'random',
                            inline=True)
            await ctx.send(embed=embed)
        elif arg1 in self.commad_details:
            embed = discord.Embed(title=f'{COMMAND_PREFIX}' + arg1,
                                  description=self.commad_details[arg1],
                                  color=0xD8BFD8
                                  )
            await ctx.send(embed=embed)
        else:
            await ctx.reply(f"Command ' {COMMAND_PREFIX}{arg1} ' doesn't exist.")
        log(command_name='help',
            member=ctx.author,
            guild_id=ctx.message.guild.id,
            time=datetime.now().strftime("%d/%m/%Y %H:%M:%S")
            )

    @help.error
    async def help_error(self, ctx, error):
        print(error)
        await ctx.send('Something went wrong')


# Anime Cog (gruppo di comandi anime)
# Ogni comandi utilizza il metodo get_url() fornito dal waifu_service.py (guarda gli import)
# Ogni specifico comando passa diversi argomenti.
# In questo Cog ho inserito anche degli error handler per la gestione di eventuali errori.
class Anime(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.command()
    async def waifu(self, ctx, *, member: discord.Member = None):
        member = member or ctx.author
        url = get_url('sfw', 'waifu')
        embed = discord.Embed(title='Waifu', description=f'Image generated by {member.mention}', color=0xD8BFD8)
        embed.set_image(url=url)
        await ctx.send(embed=embed)
        log(command_name='waifu',
            member=ctx.author,
            guild_id=ctx.message.guild.id,
            time=datetime.now().strftime("%d/%m/%Y %H:%M:%S")
            )

    # Questo è l'error handler del comando waifu().
    # Si costruiscono @nome_del_comando.error
    # Ogni volta che nel comando waifu avviene un errore questa funzione viene invocata
    # Nel mio caso, qualsiasi errore avvenga la risposta è sempre la stessa.
    @waifu.error
    async def waifu_error(self, ctx, error):
        print(error)
        await ctx.send('Something went wrong')

    @commands.command()
    async def neko(self, ctx, *, member: discord.Member = None):
        member = member or ctx.author
        url = get_url('sfw', 'neko')
        embed = discord.Embed(title='Neko', description=f'Image generated by {member.mention}', color=0xD8BFD8)
        embed.set_image(url=url)
        await ctx.send(embed=embed)
        log(command_name='neko',
            member=ctx.author,
            guild_id=ctx.message.guild.id,
            time=datetime.now().strftime("%d/%m/%Y %H:%M:%S")
            )

    @neko.error
    async def neko_error(self, ctx, error):
        print(error)
        await ctx.send('Something went wrong')

    @commands.command()
    async def shinobu(self, ctx, *, member: discord.Member = None):
        member = member or ctx.author
        url = get_url('sfw', 'shinobu')
        embed = discord.Embed(title='Shinobu', description=f'Image generated by {member.mention}', color=0xD8BFD8)
        embed.set_image(url=url)
        await ctx.send(embed=embed)
        log(command_name='shinobu',
            member=ctx.author,
            guild_id=ctx.message.guild.id,
            time=datetime.now().strftime("%d/%m/%Y %H:%M:%S")
            )

    @shinobu.error
    async def shinobu_error(self, ctx, error):
        print(error)
        await ctx.send('Something went wrong')

    @commands.command()
    async def megumin(self, ctx, *, member: discord.Member = None):
        member = member or ctx.author
        url = get_url('sfw', 'megumin')
        embed = discord.Embed(title='Megumin', description=f'Image generated by {member.mention}', color=0xD8BFD8)
        embed.set_image(url=url)
        await ctx.send(embed=embed)
        log(command_name='megumin',
            member=ctx.author,
            guild_id=ctx.message.guild.id,
            time=datetime.now().strftime("%d/%m/%Y %H:%M:%S")
            )

    @megumin.error
    async def megumin_error(self, ctx, error):
        print(error)
        await ctx.send('Something went wrong')

    @commands.command()
    async def bully(self, ctx, *, member: discord.Member = None):
        member = member or ctx.author
        url = get_url('sfw', 'bully')
        embed = discord.Embed(title='Bully', description=f'Gif generated by {member.mention}', color=0xD8BFD8)
        embed.set_image(url=url)
        await ctx.send(embed=embed)
        log(command_name='bully',
            member=ctx.author,
            guild_id=ctx.message.guild.id,
            time=datetime.now().strftime("%d/%m/%Y %H:%M:%S")
            )

    @bully.error
    async def bully_error(self, ctx, error):
        print(error)
        await ctx.send('Something went wrong')

    @commands.command()
    async def cuddle(self, ctx, *, member: discord.Member = None):
        member = member or ctx.author
        url = get_url('sfw', 'cuddle')
        embed = discord.Embed(title='Cuddle', description=f'Gif generated by {member.mention}', color=0xD8BFD8)
        embed.set_image(url=url)
        await ctx.send(embed=embed)
        log(command_name='cuddle',
            member=ctx.author,
            guild_id=ctx.message.guild.id,
            time=datetime.now().strftime("%d/%m/%Y %H:%M:%S")
            )

    @cuddle.error
    async def cuddle_error(self, ctx, error):
        print(error)
        await ctx.send('Something went wrong')

    @commands.command()
    @commands.is_nsfw()
    @commands.cooldown(1, 10, commands.BucketType.user)
    async def hsearch(self, ctx, *args):

        if len(args) >= 3:
            await ctx.reply("Max 2 arguments")
            return

        post = get_post(args)

        if post == 404:
            await ctx.reply("Search error, retry.\n")
            return

        if post[1] == 'img':
            await ctx.reply(post[0])
        else:
            video_path = 'assets/pfps/hsearch.' + post[1]
            urllib.request.urlretrieve(post[0], video_path)
            await ctx.send(file=discord.File(video_path))
            os.remove(video_path)

        log(command_name='hsearch',
            member=ctx.author,
            guild_id=ctx.message.guild.id,
            time=datetime.now().strftime("%d/%m/%Y %H:%M:%S")
            )

    @hsearch.error
    async def hsearch_error(self, ctx, error):
        if isinstance(error, commands.errors.NSFWChannelRequired):
            return await ctx.reply("NSFW Command. You must use this command in an Age-Restricted channel.")

        if isinstance(error, commands.CommandOnCooldown):
            return await ctx.reply(f"Retry this command after {error.retry_after} seconds")
        
        print(error)
        await ctx.send('Something went wrong')


class CommandErrorHandler(commands.Cog):

    def __init__(self, bot):
        self.bot = bot

    @commands.Cog.listener()
    async def on_command_error(self, ctx, error):
        if isinstance(error, commands.CommandNotFound):
            return await ctx.reply(f"Command ' {ctx.message.content[1:]} ' doesn't exist.")


# Image Cog (gruppo di comandi Image)
# In questo gruppo ci sono tutti i comandi che manipolano le immagini fornite in input oppure vengono prese le propic
# degli user che invocano questi comandi.
class Image(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.command()
    async def image(self, ctx, *args, member: discord.Member = None, avatar_path=None):

        if not os.path.exists(f'assets/guilds/{ctx.message.guild.id}/'):
            dir_init(ctx.message.guild.id)

        # Controlla se sono state messe due immagini ed è stato taggato qualcuno
        if len(ctx.message.attachments) >= 2 and ctx.message.mentions:
            await ctx.reply("You have to either attach a max of two images or an image with the mention of a user.")
            return

        # Contralla se le menzioni sono state fatte a dei ruoli. In caso invia un messaggio di errore.
        if ctx.message.role_mentions:
            await ctx.reply("You must mention an user.")
            return

        # Creazione della data ora
        now = datetime.now()
        dt_string = now.strftime("%d_%m_%Y_%H_%M_%S")

        # Controlla se esiste del testo nel comando. Se c'è la variabile 'text' verrà creata
        text: str = ''
        if args:
            for i in args:
                if not i[0] == '<':
                    text = text + i + " "
            text = text[:-1]
            f = open(f"assets/guilds/{ctx.message.guild.id}/texts.txt", "a")
            f.write(text + '\n')
            f.close()

        # Controlla se sono state menzionate delle persone nel comando
        if ctx.message.mentions:  # Sono state menzionate persone
            member = ctx.message.mentions[0]  # 'member' è la persona menzionata
        else:  # Non sono state menzionate persone
            member = member or ctx.author  # 'member' è la persona che ha invocato il comando

        # Controlla se ci sono file allegati al comando.
        if not ctx.message.attachments:  # Non ci sono file allegati

            # Salva la propic
            avatar_path = f'assets/pfps/{member.id}_pfp.png'
            await member.display_avatar.save(avatar_path)

            image_path = get_image(member_id=member.id, guild_id=ctx.message.guild.id, text=text)
            # L'immagine di sfondo sarà un caracal

        elif len(ctx.message.attachments) == 1:  # Ci sono file allegati

            avatar_path = f'assets/pfps/{member.id}_pfp.png'
            await member.display_avatar.save(avatar_path)

            extension = ctx.message.attachments[0].content_type[6:]  # Viene presa l'estensione del file come stringa

            # Controlla se l'esensione è valida. Estensioni valide: png, jpg, jpeg.
            # Se non è valida viene mandata una risposta la comando con il seguente messaggio. (comando interrotto)
            if extension != 'png' and extension != 'jpg' and extension != 'jpeg':
                await ctx.reply('Attached file not valid. The file must have one of those extension:'
                                ' **png**, **jpg** or **jpeg**.')
                return

            # Il file allegato viene salvato nel database
            attachment_path = f'assets/guilds/{ctx.message.guild.id}/attachments/{member.id}_{dt_string}_attachment.{extension} '
            await ctx.message.attachments[0].save(attachment_path)

            # Viene eseguito il metodo get_image() fornito da images_service.py
            image_path = get_image(member_id=member.id,
                                   guild_id=ctx.message.guild.id,
                                   attachment1_path=attachment_path,
                                   text=text)

        else:  # In questo caso ci sono più allegati. Nel caso noi prendiamo solo i primi due.

            extension1 = ctx.message.attachments[0].content_type[6:]  # Viene presa l'estensione del file come stringa
            extension2 = ctx.message.attachments[1].content_type[6:]

            # Controlla se l'esensione è valida. Estensioni valide: png, jpg, jpeg.
            # Se non è valida viene mandata una risposta la comando con il seguente messaggio. (comando interrotto)
            if extension1 != 'png' and extension1 != 'jpg' and extension1 != 'jpeg':
                await ctx.reply('Attached file n.1 not valid. The file must have one of those extension:'
                                ' **png**, **jpg** or **jpeg**.')
                return

            if extension2 != 'png' and extension2 != 'jpg' and extension2 != 'jpeg':
                await ctx.reply('Attached file n.2 not valid. The file must have one of those extension:'
                                ' **png**, **jpg** or **jpeg**.')
                return

            # Il file allegato viene salvato nel database
            attachment1_path = f'assets/guilds/{ctx.message.guild.id}/attachments/{member.id}_{dt_string}_attachment1.{extension1}'
            await ctx.message.attachments[0].save(attachment1_path)
            attachment2_path = f'assets/guilds/{ctx.message.guild.id}/attachments/{member.id}_{dt_string}_attachment2.{extension2}'
            await ctx.message.attachments[1].save(attachment2_path)

            # Viene eseguito il metodo get_image() fornito da images_service.py
            image_path = get_image(member_id=member.id,
                                   guild_id=ctx.message.guild.id,
                                   attachment1_path=attachment1_path,
                                   attachment2_path=attachment2_path,
                                   text=text)

        # 'image_path' rappresenta il percorso dell'immagine modificata all'interno del database

        # L'immagine viene allegata ad un Embed che poi verrà inviato in chat.
        # Immagine
        file = discord.File(image_path, filename="image.png")
        # Creazione dell'embed
        embed = discord.Embed(title='Image', description=f'Image gerenerated by {ctx.author.mention}',
                              color=0xD8BFD8)
        # Inserimento dell'immagine nell'embed
        embed.set_image(url="attachment://image.png")
        # Inserimento della data in fondo all'embed
        embed.set_footer(text=now.strftime("%m/%d/%Y %H:%M:%S"))

        # Invio dell'embed
        await ctx.send(file=file, embed=embed)
        # Cancellazione del comando inviato
        await ctx.message.delete()
        # Cancellazione dell'avatar
        if avatar_path is not None:
            os.remove(avatar_path)
        os.remove(image_path)
        log(command_name='image',
            member=ctx.author,
            guild_id=ctx.message.guild.id,
            time=datetime.now().strftime("%d/%m/%Y %H:%M:%S")
            )

    # Funzionamento molto simile al comando image()
    @commands.command()
    async def reaction(self, ctx, *, member: discord.Member = None, avatar_path=None):

        if not os.path.exists(f'assets/guilds/{ctx.message.guild.id}/'):
            dir_init(ctx.message.guild.id)

        # Controlla se sono state mandate file e se è stato menzionato qualcuno
        # Se tutte e due le azioni sono state eseguite il invia un messaggio di errore
        if ctx.message.mentions and ctx.message.attachments:
            await ctx.reply("You have to either attach an image or mention a user.")
            return

        # Contralla se le menzioni sono state fatte a dei ruoli. In caso invia un messaggio di errore.
        if ctx.message.role_mentions:
            await ctx.reply("You must mention an user.")
            return

        # Creazione della data ora
        now = datetime.now()
        dt_string = now.strftime("%d_%m_%Y_%H_%M_%S")

        # Esegue tutti i vari controlli elencati nel comando image()
        if ctx.message.mentions:
            member = ctx.message.mentions[0]
        else:
            member = member or ctx.author

        if not ctx.message.attachments:
            avatar_path = f'assets/pfps/{member.id}_pfp.png'
            await member.display_avatar.save(avatar_path)
            # Il metodo invocato qui è il get_reaction() fornito dal images_service.py
            image_path = get_reaction(member_id=member.id, guild_id=ctx.message.guild.id)

        else:
            # Controllo dell'estensione
            extension = ctx.message.attachments[0].content_type[6:]
            if extension != 'png' and extension != 'jpg' and extension != 'jpeg':
                await ctx.reply('Attached file not valid. The file must have one of those extension:'
                                ' **png**, **jpg** or **jpeg**.')
                return
            attachment_path = f'assets/guilds/{ctx.message.guild.id}/attachments/{member.id}_{dt_string}_attachment.{extension}'
            await ctx.message.attachments[0].save(attachment_path)
            # Il metodo invocato qui è il get_reaction() fornito dal images_service.py
            image_path = get_reaction(member_id=member.id, guild_id=ctx.message.guild.id,
                                      attachment_path=attachment_path)

        # Creazione e invio dell'embed
        file = discord.File(image_path, filename="image.png")
        embed = discord.Embed(title='Reaction', description=f'Reaction gerenerated by {ctx.author.mention}',
                              color=0xD8BFD8)
        embed.set_image(url="attachment://image.png")
        embed.set_footer(text=now.strftime("%m/%d/%Y %H:%M:%S"))

        await ctx.send(file=file, embed=embed)
        await ctx.message.delete()
        if avatar_path is not None:
            os.remove(avatar_path)
        os.remove(image_path)
        log(command_name='reaction',
            member=ctx.author,
            guild_id=ctx.message.guild.id,
            time=datetime.now().strftime("%d/%m/%Y %H:%M:%S")
            )

    @commands.command()
    async def avatar(self, ctx, *, member: discord.Member = None):

        now = datetime.now()

        if ctx.message.mentions:
            member = ctx.message.mentions[0]
        else:
            member = member or ctx.author

        url = member.display_avatar.url
        embed = discord.Embed(title='Avatar', description=f'This is {member.mention} avatar',
                              color=0xD8BFD8)
        embed.set_image(url=url)
        embed.set_footer(text=now.strftime("%m/%d/%Y %H:%M:%S"))
        await ctx.send(embed=embed)
        log(command_name='avatar',
            member=ctx.author,
            guild_id=ctx.message.guild.id,
            time=datetime.now().strftime("%d/%m/%Y %H:%M:%S")
            )

    @commands.command()
    async def random(self, ctx, *, member: discord.Member = None):

        if not os.path.exists(f'assets/guilds/{ctx.message.guild.id}/'):
            dir_init(ctx.message.guild.id)

        try:
            attachment1_path = f"assets/guilds/{ctx.message.guild.id}/attachments/" + \
                               random.choice(os.listdir(f"assets/guilds/{ctx.message.guild.id}/attachments"))
            attachment2_path = f"assets/guilds/{ctx.message.guild.id}/attachments/" + \
                               random.choice(os.listdir(f"assets/guilds/{ctx.message.guild.id}/attachments"))
        except IndexError:
            await ctx.reply("The ***attachments*** directory of this server is empty.\n"
                            "You can fill the directory by using commands like: *image*, *reaction*... with "
                            "allegation. \n"
                            "The more images there are in the folder, the more possible random images will be "
                            "generated.")
            return

        member = member or ctx.author
        now = datetime.now()

        rand = random.randrange(0, 101)
        if rand < 66:
            lines = open(f"assets/guilds/{ctx.message.guild.id}/texts.txt").read().splitlines()
            text = random.choice(lines)
        else:
            text = ''

        image_path = get_image(member_id=member.id,
                               guild_id=ctx.message.guild.id,
                               attachment1_path=attachment1_path,
                               attachment2_path=attachment2_path,
                               text=text)

        file = discord.File(image_path, filename="image.png")
        embed = discord.Embed(title='Random', description=f'Random image generated by {ctx.author.mention}',
                              color=0xD8BFD8)

        embed.set_image(url="attachment://image.png")

        embed.set_footer(text=now.strftime("%m/%d/%Y %H:%M:%S"))

        await ctx.send(file=file, embed=embed)
        os.remove(image_path)
        log(command_name='random',
            member=ctx.author,
            guild_id=ctx.message.guild.id,
            time=datetime.now().strftime("%d/%m/%Y %H:%M:%S")
            )

    @random.error
    async def random_error(self, ctx, error):
        print(error)
        await ctx.send('Something went wrong')

    @image.error
    async def image_error(self, ctx, error):
        print(error)
        await ctx.send('Something went wrong')

    @reaction.error
    async def reaction_error(self, ctx, error):
        print(error)
        await ctx.send('Something went wrong')


client.run(discord_token)
